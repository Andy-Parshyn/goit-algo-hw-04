# Порівняльний аналіз алгоритмів сортування

У цьому проекті проведено порівняння ефективності трьох алгоритмів сортування: **сортування злиттям (Merge Sort)**, **сортування вставками (Insertion Sort)** та вбудованого алгоритму сортування Python — **Timsort** (`sorted`).

## Опис алгоритмів

1.  **Merge Sort (Сортування злиттям):**
    * Алгоритм "розділяй і володарюй".
    * Теоретична складність: $O(N \log N)$.
    * Рекурсивно ділить масив навпіл, сортує частини та об'єднує їх.
2.  **Insertion Sort (Сортування вставками):**
    * Простий алгоритм, ефективний для малих наборів даних.
    * Теоретична складність: $O(N^2)$.
    * Проходить по масиву та вставляє кожен елемент на своє місце у відсортованій частині.


3.  **Timsort (Built-in Sorted):**
    * Гібридний алгоритм (поєднання сортування злиттям та вставками), що використовується як стандартний у Python.
    * Теоретична складність: $O(N \log N)$.
    * Високо оптимізована реалізація на C.

## Методологія

Вимірювання часу виконання проводилося за допомогою модуля `timeit` на різних розмірах масивів: від 100 до 100,000 елементів. Для кожного алгоритму та розміру масиву було зафіксовано час виконання в секундах.

## Результати

Емпіричні дані, отримані в результаті тестування:

| Size (N) | Merge Sort (s) | Insertion Sort (s) | Built-in (Sorted) (s) |
| :--- | :--- | :--- | :--- |
| **100** | 0.000056 | 0.000060 | 0.000005 |
| **1,000** | 0.000619 | 0.006249 | 0.000057 |
| **10,000** | 0.007090 | 0.587171 | 0.000758 |
| **100,000** | 0.089296 | 62.575231 | 0.007916 |


## Аналіз та висновки

### 1. Підтвердження теоретичної складності Insertion Sort O(N^2)
Сортування вставками демонструє стрімке зростання часу виконання зі збільшенням розміру вхідних даних.
* При збільшенні $N$ з **10,000** до **100,000** (у 10 разів), час виконання зріс з **0.58 с** до **62.57 с**.
* Співвідношення часу: $62.57 / 0.58 \approx 107.8$.
* Це майже ідеально відповідає квадратичній залежності: при збільшенні даних у 10 разів, час зростає у $10^2 = 100$ разів.
* **Висновок:** Insertion Sort непридатний для великих масивів.

### 2. Підтвердження ефективності Merge Sort O(N \log N)
Сортування злиттям показує стабільну ефективність.
* При збільшенні $N$ з **10,000** до **100,000**, час зріс з **0.007 с** до **0.089 с** (приблизно в 12.7 разів).
* Це відповідає лог-лінійній складності (трохи більше ніж лінійне зростання через логарифмічний множник).

### 3. Перевага Timsort
Вбудований алгоритм (`sorted`) виявився найшвидшим на всіх тестах.
* Він поєднує алгоритмічну ефективність O(N \log N) з низькорівневою оптимізацією (реалізація на C).
* На масиві у 100,000 елементів Timsort працює у **~11 разів швидше** за чистий Python Merge Sort та у **~7900 разів швидше** за Insertion Sort.

## Загальний висновок

Для малих масивів (до 100 елементів) різниця між Insertion Sort та Merge Sort є незначною. Однак, для великих наборів даних використання алгоритмів з квадратичною складністю (Insertion Sort) є критично неефективним. Timsort є беззаперечним лідером завдяки гібридному підходу та оптимізації інтерпретатора.
